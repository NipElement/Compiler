# 编译原理设计报告

## 1. 摘要

本报告描述了一个使用 SysY 语言实现的编译器，该编译器可以将 SysY 语言的源代码转换为目标代码。该项目涉及词法分析、语法分析、生成 LLVM IR，最终利用 LLVM 执行生成的 IR 生成目标代码。作为验证，我们编写了快速排序和矩阵乘法的 SysY 代码，并通过了相应的测试。

## 2. 系统设计

### 2.1 SysY语言

SysY 语言是一种简易的、类似 C 的编程语言，设计用于教学和研究目的。由于它的简洁性，SysY 语言可以帮助我们更容易地理解基本的编程概念，以下是 SysY 语言的一些主要特点：

1. 基本数据类型：SysY 语言支持整型（int）作为唯一的基本数据类型。整型可以用于表示整数、布尔值等。
2. 变量与赋值：SysY 语言允许声明全局和局部变量，支持基本的变量赋值操作。变量在声明时可以初始化。
3. 控制结构：SysY 语言提供了基本的控制结构，如条件语句（if-else）、循环语句（while、for）等。这使得程序员能够无缝地处理不同的程序分支和循环迭代。
4. 函数：SysY 支持函数的定义和调用。函数可以定义返回值类型（仅支持整型），并可以接收一系列参数。SysY 支持递归函数调用。
5. 数组：SysY 语言支持一维和多维数组。数组的元素类型是整型。可以在声明时指定数组长度和初始化数组元素。
6. 表达式：SysY 提供了丰富的表达式支持，包括算术、逻辑、关系和位操作符。与 C 语言类似，SysY 允许使用括号来指定运算顺序。
7. 注释：SysY 语言支持 C 风格的单行（使用 `//`）和多行（使用 `/*` 和 `*/`）注释。

SysY 语言的文法采用扩展的 Backus 范式 (EBNF, Extended Backus-Naur Form) 表示, 其中:

- 符号 `[...]` 表示方括号内包含的项可被重复 0 次或 1 次.
- 符号 `{...}` 表示花括号内包含的项可被重复 0 次或多次.
- 终结符是由双引号括起的串, 或者是 `IDENT`, `INT_CONST` 这样的大写记号. 其余均为非终结符.

SysY 语言的文法表示如下, `CompUnit` 为开始符号:

```c
CompUnit      ::= [CompUnit] (Decl | FuncDef);

Decl          ::= ConstDecl | VarDecl;
ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
BType         ::= "int";
ConstDef      ::= IDENT {"[" ConstExp "]"} "=" ConstInitVal;
ConstInitVal  ::= ConstExp | "{" [ConstInitVal {"," ConstInitVal}] "}";
VarDecl       ::= BType VarDef {"," VarDef} ";";
VarDef        ::= IDENT {"[" ConstExp "]"}
                | IDENT {"[" ConstExp "]"} "=" InitVal;
InitVal       ::= Exp | "{" [InitVal {"," InitVal}] "}";

FuncDef       ::= FuncType IDENT "(" [FuncFParams] ")" Block;
FuncType      ::= "void" | "int";
FuncFParams   ::= FuncFParam {"," FuncFParam};
FuncFParam    ::= BType IDENT ["[" "]" {"[" ConstExp "]"}];

Block         ::= "{" {BlockItem} "}";
BlockItem     ::= Decl | Stmt;
Stmt          ::= LVal "=" Exp ";"
                | [Exp] ";"
                | Block
                | "if" "(" Exp ")" Stmt ["else" Stmt]
                | "while" "(" Exp ")" Stmt
                | "break" ";"
                | "continue" ";"
                | "return" [Exp] ";";

Exp           ::= LOrExp;
LVal          ::= IDENT {"[" Exp "]"};
PrimaryExp    ::= "(" Exp ")" | LVal | Number;
Number        ::= INT_CONST;
UnaryExp      ::= PrimaryExp | IDENT "(" [FuncRParams] ")" | UnaryOp UnaryExp;
UnaryOp       ::= "+" | "-" | "!";
FuncRParams   ::= Exp {"," Exp};
MulExp        ::= UnaryExp | MulExp ("*" | "/" | "%") UnaryExp;
AddExp        ::= MulExp | AddExp ("+" | "-") MulExp;
RelExp        ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
EqExp         ::= RelExp | EqExp ("==" | "!=") RelExp;
LAndExp       ::= EqExp | LAndExp "&&" EqExp;
LOrExp        ::= LAndExp | LOrExp "||" LAndExp;
ConstExp      ::= Exp;
```

### 2.2 词法分析器

#### 2.2.1 词法分析器模块概述

词法分析器 (Lexer) 是编译器中的一个关键模块，它的主要任务是将由源代码组成的字符序列转换为有意义的符号流（Token）。词法分析器负责识别源代码中的单词符号，包括关键字、变量名、数据类型、操作符等。

词法分析器作为编译过程的第一个阶段，是编译器框架的基础部分。在整个编译系统中，词法分析器通常与语法分析器（Parser）协同工作，共同完成源代码的解析过程。

#### 2.2.2 模块设计目的

词法分析器的设计目的是将源代码中的字符串分解为有意义的词汇单元（Token），并消除源代码中的空格、换行符等不必要字符，为后续的语法分析阶段提供简化版的输入。

#### 2.2.3 设计方案与思想

在本项目中，我们选择使用 Flex（一个词法分析器生成工具）来实现词法分析器。基于 Flex 来构建词法分析器，有以下几点优势:

- 可以轻松定义识别模式和相应的动作。
- Flex 会自动处理缓冲区管理、输入输出等底层细节。
- 与 Bison（一个用于生成语法分析器的工具）配合使用时，可以比较轻松地实现后续的编译器。

词法分析器负责将 SysY 语言的源代码转换为 token 序列。我们编写了一个词法分析器，它可以识别 SysY 语言的关键字、标识符、操作符、字面量等，同时每个正则表达式都会与一个相应的动作关联起来。

我们在 Flex 规约文件 `lexer.l` 中定义了 SysY 语言的词汇规则，以及识别到相应词汇时执行的代码动作，代码如下。

*lexer.l 规约代码*

```c
%option noyywrap
%option nounput
%option noinput

%{

#include <cstdlib>
#include <string>

// 因为 Flex 会用到 Bison 中关于 token 的定义
// 所以需要 include Bison 生成的头文件
#include "../build/parser.tab.hpp"

using namespace std;

%}

/* 空白符和注释 */
WhiteSpace    [ \t\n\r]*
LineComment   "//".*

/* 标识符 */
Identifier    [a-zA-Z_][a-zA-Z0-9_]*

/* 整数字面量 */
Decimal       [1-9][0-9]*
Octal         0[0-7]*
Hexadecimal   0[xX][0-9a-fA-F]+

String        \"[^\"]*\"


%%

{WhiteSpace}    { /* 忽略, 不做任何操作 */ }
{LineComment}   { /* 忽略, 不做任何操作 */ }

"int"           { return INT; }
"return"        { return RETURN; }
"void"          { return VOID; }
"const"         { return CONST;}
"while"         { return WHILE; }
"if"            { return IF; }
"else"          { return ELSE; }
"break"         { return BREAK; }
"continue"      { return CONTINUE; }
">="            { return GE; }
"<="            { return LE; }
">"             { return GT; }
"<"             { return LT; }
"=="            { return EQ; }
"!="            { return NE; }
"&&"            { return AND; }
"||"            { return OR; }

{Identifier}    { yylval.str_val = new string(yytext); return IDENT; }

{Decimal}       { yylval.int_val = strtol(yytext, nullptr, 0); return INT_CONST; }
{Octal}         { yylval.int_val = strtol(yytext, nullptr, 0); return INT_CONST; }
{Hexadecimal}   { yylval.int_val = strtol(yytext, nullptr, 0); return INT_CONST; }

{String}        { yylval.str_val = new string(yytext); return STR; }

.               { return yytext[0]; }

%%

```

#### 2.2.4 模块特性

通过使用 Flex 来生成词法分析器，我们实现了以下特性：

- 准确识别 SysY 语言的关键字、变量名、操作符、数据类型等词汇单元。
- 自动消除源代码中的空白字符、换行符等不必要字符。
- 用户友好的错误报告，当源代码存在无法识别的符号时，提供清晰的出错信息。
- 与 Bison 生成的语法分析器紧密集成，为后续的语法分析阶段提供舒适的接口。

#### 2.2.5 使用本模块的方法？

词法分析器模块使用 Flex 工具生成。首先需要创建一个名为 `lexer.l` 的 Flex 规约文件，其中包含 SysY 语言的词汇规则定义以及识别相应词汇时执行的代码动作。然后使用 `flex` 命令来生成词法分析器的源代码 (lexer.c)：

```
flex lexer.l
```

词法分析器的源代码文件（lexer.c）可以与其他源代码文件一起编译，以生成完整的编译器。在编译器中，可以通过调用词法分析器的相关函数（例如 `yylex()`）来开始词法分析过程，并将生成的 Token 传递给后续的语法分析阶段。

### 2.3 语法分析器

语法分析器将由词法分析器生成的 token 序列转换为抽象语法树（AST）。我们使用了递归下降方法实现 SysY 语言的语法分析器。

#### 2.3.1 语法分析器模块概述

语法分析器 (Parser) 是编译器的关键模块之一。它的主要任务是根据词法分析器生成的 Token 序列来分析程序的语法结构并构建抽象语法树 (Abstract Syntax Tree, AST)。AST 以树形结构表示程序代码，能够准确地展现代码的层次与逻辑关系。

语法分析器在整个编译过程中紧跟在词法分析器之后，负责解析源代码的结构。此外，语法分析器还需要处理语法中的歧义和优先级问题，确保程序的逻辑正确。

#### 2.3.2 模块设计目的

设计语法分析器的主要目的是捕捉源代码中的逻辑关系和控制结构。通过构建抽象语法树，将源代码转换为更容易处理的结构化模型，将方便后续的代码生成阶段。

#### 2.3.3 设计方案与思想

在本项目中，我们选择使用 Bison（一个生成语法分析器的工具）来构建 SysY 语言的语法分析器，并结合一组自定义的AST节点类来构建抽象语法树。Bison 可以有效地将上下文无关文法表示为可执行程序，与 Flex 词法分析器生成工具配合使用，可以方便地实现完整的编译器。

为了表示抽象语法树，我们定义了一组AST节点类，它们都继承自基类`BaseAST`。这些节点类表示了程序代码中不同的结构和语义元素，如声明、函数定义、表达式等。在Bison动作中，我们将创建这些节点类的对象，并根据语法规则将它们组织为一棵树形结构。开始节点及CompUnit定义如下：

```c++
enum ASTtype {
  base,
  comp_unit,
  //..
};
class BaseAST {
 public:
  ASTtype type;
  int id;
  virtual void printTree() = 0;
  virtual std::vector<BaseIr *> buildIrNodes(){};
  virtual BaseIr *buildIrTree(){};
  virtual ~BaseAST() = default;
};

class StartRoot : public BaseAST {
 public:
  std::unique_ptr<BaseAST> comp_unit_ast;
  virtual void printTree() override;
  virtual BaseIr *buildIrTree();
  virtual ~StartRoot() override{};
};

class CompUnitAST : public BaseAST {
 public:
  std::unique_ptr<BaseAST> func_def_ast;
  std::unique_ptr<BaseAST> decl_ast;
  std::unique_ptr<BaseAST> comp_unit_ast;
  virtual void printTree() override;
  virtual ~CompUnitAST() override{};
};
```

其余节点定义也类似。

接着，我们使用 Bison 构建语法分析器，首先创建一个名为 `parser.y` 的文件，其中包含 SysY 语言语法规则的定义。同时，在定义语法规则时，我们为每个规则都关联一个动作。在动作中，我们根据当前处理的规则来实例化相应的AST节点，并通过设置其子节点及属性来构建出完整的抽象语法树。开始节点及CompUnit定义如下：

```c++
StartRoot
  : CompUnit {
    auto start_root = make_unique<StartRoot>();;
    start_root->comp_unit_ast = std::unique_ptr<BaseAST>($1);
    start_root->id = id++;
    ast = move(start_root);
    //std::cout<<"CompUnit"<<endl;
  }
  ;

CompUnit
  : CompUnit FuncDef {
    auto ast = new CompUnitAST();
    ast->comp_unit_ast = unique_ptr<BaseAST>($1);
    ast->decl_ast = nullptr;
    ast->func_def_ast = unique_ptr<BaseAST>($2);
    ast->id = id++;
    $$ = ast;
    //std::cout<<"CompUnit FuncDef"<<endl;
  }
  | {
      $$ = nullptr;
  }
  ;
```

这段代码是根据 SysY 语言的语法规则来定义的，它的主要作用是接收词法分析器提供的 Token 序列并根据这些 Tokens 构建抽象语法树。

首先，我们定义了两个规则：`StartRoot` 和 `CompUnit`。

- `StartRoot` 规则：在这个规则中，我们期望从 `CompUnit` 规则得到一个 `BaseAST` 对象。接着，我们创建一个 `StartRoot` 对象，并将其子树设置为从 `CompUnit` 规则得到的树。最后，为了确保树的结构的唯一性，我们为每个 `StartRoot` 节点分配一个唯一的 ID。

```c++
StartRoot
  : CompUnit {
    auto start_root = make_unique<StartRoot>();;
    start_root->comp_unit_ast = std::unique_ptr<BaseAST>($1);
    start_root->id = id++;
    ast = move(start_root);
    //std::cout<<"CompUnit"<<endl;
  }
  ;
```

- `CompUnit` 规则：这个规则定义了如何构建一个包含声明（`Decl`）和函数定义（`FuncDef`）的复合单元。这个规则包含两个候选项，它们分别处理声明或函数定义的递归组合，或者是一个空节点：

  - 第一个候选项表示一个 `CompUnit` 后面跟着一个 `FuncDef`。这里，我们创建一个 `CompUnitAST` 对象，并将其子树设置为从 `CompUnit` 和 `FuncDef` 规则得到的树，同时将其 `decl_ast` 设为 `nullptr`。最后，为每个 `CompUnitAST` 节点分配一个唯一的 ID。
  
  ```c++
  | CompUnit FuncDef {
    auto ast = new CompUnitAST();
    ast->comp_unit_ast = unique_ptr<BaseAST>($1);
    ast->decl_ast = nullptr;
    ast->func_def_ast = unique_ptr<BaseAST>($2);
    ast->id = id++;
    $$ = ast;
    //std::cout<<"CompUnit FuncDef"<<endl;
  }
  ```
  
  - 第二个候选项表示匹配空字符串的情况。在这种情况下，我们将返回值设为 `nullptr`。
  
  ```c++
  | {
      $$ = nullptr;
  }
  ;
  ```

其他规则也类似这样进行定义，在根据SysY语言的语法规则完成编写后，我们就可以将输入代码有效地解析为树形结构的抽象语法树，从而为后续的编译过程提供有价值的信息。在语法分析器模块设计过程中，我们权衡了灵活性、易用性以及性能等因素，通过使用Bison工具及自定义AST节点类来实现一个高效、可维护的语法分析器。

#### 2.3.4 模块特性

通过使用 Bison 生成语法分析器，我们实现了以下特性：

- 准确解析 SysY 语言的语法结构，如声明、表达式、控制结构等。
- 自动生成高效且可维护的解析器工具。
- 编写简洁易懂的语法规则描述文件。
- 与 Flex 生成的词法分析器紧密集成。
- 构建抽象语法树 (AST) 以方便后续阶段处理。

#### 2.3.5 使用本模块的方法

要使用本模块，需要首先编写 `parser.y` 文件，定义语法规则以及解析这些规则形成 AST 时执行的相关动作。然后，利用 Bison 工具编译生成语法分析器源代码。源代码文件中包括一个名为 "yyparse()" 的函数。在主函数中，需要先调用词法分析器，然后调用 "yyparse()" 函数开始语法分析过程，最终生成抽象语法树。

### 2.4 生成 LLVM IR

#### 2.4.1 生成 LLVM IR 模块概述

生成 LLVM IR（中间表示）模块的主要目的是将由语法分析器生成的抽象语法树（AST）转换为 LLVM IR，这样我们可以利用 LLVM 的优化、代码生成等工具来为不同的平台生成可执行文件。

LLVM IR 是一种中间表示形式，它是一种能够方便地表示高级编程语言结构的低级别模型。通过生成 LLVM IR，我们可以将 SysY 语言的编译与 LLVM 的底层实现、优化和目标平台生成代码解耦。

#### 2.4.2 模块设计目的

模块的主要目的是将抽象语法树转换为对应的 LLVM IR 代码，进一步优化和生成目标平台的可执行文件。通过生成 LLVM IR，我们可以利用 LLVM 提供的各种工具和功能，优化生成的代码，确保生成的目标代码具有较好的性能。

#### 2.4.3 设计方案与思想

在本项目中，我们为每一个 AST 节点类实现了一个将该节点转换为 LLVM IR 代码的方法。这些方法递归地遍历整个 AST，并根据每个节点的类型和属性生成对应的 LLVM IR 代码。

我们通过编写代码来生成 LLVM IR 的相应指令，如赋值、运算、控制流等。我们还确保生成的代码遵循 LLVM IR 的规范，如 SSA（Static Single Assignment）形式等。

为了实现这一设计，我们首先学习了 LLVM IR 的语法和规范。接着，我们阅读了 LLVM 的文档和源代码，了解了如何使用 LLVM 提供的 API 来动态地生成相应的 IR 代码。在实现过程中，我们始终关注生成的 IR 代码的正确性和优化潜力。

#### 2.4.4 模块特性

通过实现生成 LLVM IR 模块，我们实现了如下特性：

- 递归地将抽象语法树转换为相应的 LLVM IR 代码
- 生成符合 LLVM IR 规范的代码
- 充分利用 LLVM 提供的 API 来简化代码生成过程
- 在生成的 IR 代码中保留了源代码的结构和语义信息
- 为后续的 LLVM 优化和目标代码生成提供了良好的基础

#### 2.4.5 使用本模块的方法

要使用本模块，需要首先确保已经成功生成了抽象语法树（AST）。之后，对每个 AST 节点调用实现的生成 LLVM IR 的方法。该方法会递归地产生整个 AST 对应的 LLVM IR 代码。

在生成完成后，可以将得到的 LLVM IR 代码传递给 LLVM 提供的优化和目标代码生成工具，为不同平台生成可执行文件。同时，可以将 IR 代码输出到文件或控制台，以便于分析和调试。

通过本模块的设计，SysY 语言编译器可以方便地生成对应的 LLVM IR 代码，进一步推动编译过程。

在本项目的实现示例中，我们将生成的IR按照对应输出规则打印到控制台输出，使用 `ast->printTree()` 方法展示生成的 IR树结构。

其中打印输出的内容可以放置到 https://graphviz.christine.website/ 中进行AST语法树的查看。

比如对以下的简单代码

```c++
int main()
{
    int a;
    a = 0;
    return 0;
}
```

通过语法分析器生成AST后可以输出以下内容

```

```

通过Graphviz网站可以显示对应的可视化树形结构如下：



### 2.5 生成目标代码

我们使用 LLVM 的功能执行生成的 LLVM IR，并生成最终的目标代码。

*代码片段 4：利用 LLVM 生成目标代码的部分代码*

## 3. 测试与验证

为了验证我们的编译器是否正确实现了 SysY 语言的功能，我们编写了快速排序和矩阵乘法的代码，并通过了相应的测试。

### 3.1 快速排序

我们编写了一个 SysY 语言程序，实现了基本的快速排序算法。

*代码片段 5：快速排序代码*

*结果 1：快速排序测试结果*

### 3.2 矩阵乘法

我们编写了一个 SysY 语言程序，实现了矩阵乘法算法。

*代码片段 6：矩阵乘法代码*

*结果 2：矩阵乘法测试结果*

## 4. 结论

通过系统设计、实现和测试，我们成功地实现了一个可以将 SysY 语言源代码转换为目标代码的编译器。该编译器在快速排序和矩阵乘法的测试中表现良好。这说明我们的编译器有效地实现了 SysY 语言的主要功能，可以用于进一步的应用和研究。

## 5. 参考文献

[空位：待添加参考文献]

附件：

1. 快速排序 SysY 代码
2. 矩阵乘法 SysY 代码